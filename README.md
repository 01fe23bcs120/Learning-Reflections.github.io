# Learning-Reflections.github.io
# Hello Everyone,Welcome to our Vision!..
## I'm Tanushree-An enthusiastic learner and a problem solver
I am a student at KLE Technological University, pursuing computer science course.
# Course Learning Reflection
## 1. Foundation
-Time Complexity: How fast an algorithm runs.  
-Space Complexity: Extra space the algorithm requires.   
-Order of Growth: A way to approximate how long it takes to run a computer program as the size of its input increases. 
## 2. Nature of Problem
-Recursive: Characterized by recurrence or repetition.  
-Iterative: The act of repeating a process with the aim of approaching a desired goal, target or result.  
-BackTracking: Removing the present solution to a problem if it is inadequate or unsuitable, going back (Backtracking), and trying a different approach.
## 3. Sorting Algorithms
-Mergesort: Split the list into simplest parts and sort them, and later combine them.  
-Quicksort: Considering a pivotal entry and placing it to its correct position.  
-Heapsort: Placing the highest or smallest value in the root of the tree, and later finding second one by heapifying it.  
## 4. String Search Algorithms
-Knuth-Morris-Pratt Algorithm: Creating a prefix table to reduce the number of comparisons and increase number of shifts.  
-Rabin Karp: Creating a hash table we create hash value for the pattern and compare it with the text part hash value.  
-Boyer-Moore: Creating Bad symbol shift table and Good suffix table to find our pattern in much more efficient way.  
## 5. Trees
-Binary Search Tree: It helps in managing heirerical data.  
-AVL/Red-Black Trees: It helps in balancing the binary search tree.   
-Trie: It helps in finding a particular text, and are ranked based on how often they are used.  
-Heap: It stores maximum or minimum value at the root node, which helps us to fetch instantly.  
## 6. Range Queries
-Fenwick Tree: Helps in calculating sum of elements in very less time, it uses concept of isolating last bit.  
-Segment Tree: Information is stored in terms of intervals.
## 7. Graph Algorithms
-Depth First Search(DFS): It traverses till the dead end and backtracks.  
-Breadth First Search(BFS): It traverses first its neighbouring nodes then moves to next level.  
-Prim and Kruskal: It helps in finding minimum spanning tree of a given graph.  
-Dijkstra’s and BellmanFord: It helps in finding the shortest path of a source vertex.  
-Floyd and Warshall: It helps in finding the all shortest pair path and also finds wether a path exists or not.
## 8. Design Techniques
-Brute Force: Brute force is a straight forward approach to solving a problem.  
-Space and Time trade off: A space–time or time–memory trade-off is a case where an algorithm or program trades increased space usage with decreased time.  
-Greedy Technique: A problem-solving method that selects the best option at each step to achieve a goal.  
-Dynamic Programming:A technique where an algorithmic problem is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution.
